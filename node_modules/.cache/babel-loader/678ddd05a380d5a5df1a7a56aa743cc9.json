{"ast":null,"code":"import _slicedToArray from \"/Users/lttttoai/Documents/GitHub/carovn/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/* eslint-disable no-return-assign */\n\n/* eslint-disable no-plusplus */\n\n/* eslint-disable no-console */\nconst streaks = {\n  nine: [// all the possible line streaks that could make a winner.\n  [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]],\n  sixteen: [[0, 1, 2, 3, 4], [2, 3, 4, 5, 6], [3, 4, 5, 6, 7], [4, 5, 6, 7, 8], [5, 6, 7, 8, 9], [6, 7, 8, 9, 10], [7, 8, 9, 10, 11], [8, 9, 10, 11, 12], [9, 10, 11, 12, 13], [10, 11, 12, 13, 14], [11, 12, 13, 14, 15], [12, 13, 14, 15, 16], [13, 14, 15, 16, 17], [14, 15, 16, 17, 18], [15, 16, 17, 18, 19], [16, 17, 18, 19, 20], [17, 18, 19, 20, 21], [18, 19, 20, 21, 22], [19, 20, 21, 22, 23], [20, 21, 22, 23, 24], [21, 22, 23, 24, 25], [22, 23, 24, 25, 26], [23, 24, 25, 26, 27], [24, 25, 26, 27, 28], [25, 26, 27, 28, 29], [26, 27, 28, 29, 30], [0, 4, 8, 12, 14], [1, 5, 9, 13, 17], [2, 6, 10, 14, 18], [3, 7, 11, 15, 19], [0, 5, 10, 15, 20], [3, 6, 9, 12, 15]]\n};\n\nconst indicateVictory = (cells, grid) => {\n  if (grid === 9) {\n    const possibleStreaks = streaks.nine;\n\n    for (let i = 0; i < possibleStreaks.length; i += 1) {\n      const _possibleStreaks$i = _slicedToArray(possibleStreaks[i], 3),\n            a = _possibleStreaks$i[0],\n            b = _possibleStreaks$i[1],\n            c = _possibleStreaks$i[2];\n\n      if (cells[a] && cells[a] === cells[b] && cells[a] === cells[c]) {\n        return {\n          winner: cells[a],\n          winningRow: [a, b, c]\n        };\n      }\n    }\n  } else if (grid === 16) {\n    const possibleStreaks = streaks.sixteen;\n\n    for (let i = 0; i < possibleStreaks.length; i += 1) {\n      const _possibleStreaks$i2 = _slicedToArray(possibleStreaks[i], 4),\n            a = _possibleStreaks$i2[0],\n            b = _possibleStreaks$i2[1],\n            c = _possibleStreaks$i2[2],\n            d = _possibleStreaks$i2[3];\n\n      if (cells[a] && cells[a] === cells[b] && cells[a] === cells[c] && cells[a] === cells[d]) {\n        return {\n          winner: cells[a],\n          winningRow: [a, b, c, d]\n        };\n      }\n    }\n  }\n\n  return {\n    winner: null,\n    winningRow: [null, null, null]\n  };\n};\n\nconst getGameScore = (winner, movesCount) => {\n  let score;\n  const urgency = movesCount === 0 ? -80 : movesCount; // if its an immediate win return highest score always.\n\n  if (winner === 'X') {\n    score = -20 + urgency;\n  } else if (winner === 'O') {\n    score = 20 - urgency;\n  } else {\n    score = 0;\n  }\n\n  return score;\n};\n\nconst getAvailableMoves = board => {\n  // returns an array of available cells\n  const available = [];\n  board.forEach((cell, cellIndex) => {\n    if (cell === null) {\n      available.push(cellIndex);\n    }\n  });\n  return available;\n};\n\nconst minMax = (board, xTurn, grid, depth = 0) => {\n  const _indicateVictory = indicateVictory(board, grid),\n        winner = _indicateVictory.winner;\n\n  let score = null;\n  const moves = getAvailableMoves(board);\n\n  if (winner || moves.length === 0) {\n    return getGameScore(winner, depth);\n  }\n\n  moves.forEach(move => {\n    const newBoard = board.slice();\n    newBoard[move] = xTurn ? 'X' : 'O';\n    const moveScore = minMax(newBoard, !xTurn, grid, // eslint-disable-next-line no-param-reassign\n    ++depth);\n\n    if (xTurn) {\n      if (moveScore < score || score === null) {\n        score = moveScore;\n      }\n    } else if (moveScore > score || score === null) {\n      score = moveScore;\n    }\n  });\n  return score;\n};\n\nexport const getBestMove = (board, grid, xTurn) => {\n  let bestScore = null;\n  let bestMove = null;\n  const moves = getAvailableMoves(board);\n  console.log(\"available moves: \".concat(moves.length));\n  console.log(moves); // on 4x4 grid recursive analysis is applied for 8 or less options.\n\n  if (grid === 9 || moves.length <= 8) {\n    if (grid === 9 && moves.length === 8 && !board[4]) {\n      return bestMove = 4;\n    }\n\n    moves.forEach(move => {\n      const newBoard = board.slice();\n      newBoard[move] = xTurn ? 'X' : 'O';\n      const newScore = minMax(newBoard, !xTurn, grid);\n      console.log(\"\".concat(move, \"'s score: \").concat(newScore));\n\n      if (xTurn) {\n        if (newScore < bestScore || bestScore === null) {\n          bestScore = newScore;\n          bestMove = move;\n        }\n      } else if (newScore > bestScore || bestScore === null) {\n        bestScore = newScore;\n        bestMove = move;\n      }\n    });\n  } else {\n    /* for 4x4 grids I implemented simple logic for the first few moves to reduce system overload.\n      Recursive analysis of 9 or more available moves will decrease performance and might even cause the game to crash.\n       This logic calculates threat and advantage of current board's state, compares the two and prioritises the highest.\n      Then the AI makes his move based on his current priority, if it is to block a threat or build up an advantage. */\n    const enemy = xTurn ? 'O' : 'X';\n    const self = xTurn ? 'X' : 'O';\n    let threat;\n    let advantage;\n    let priority = -1;\n\n    if (moves.length === 16) {\n      const openers = [0, 3, 12, 15];\n      openers.forEach(opener => {\n        if (!board[opener]) {\n          bestMove = opener;\n        }\n      });\n    }\n\n    streaks.sixteen.forEach(streak => {\n      threat = streak.filter(cell => {\n        return board[cell] === enemy;\n      }).length;\n      advantage = streak.filter(cell => {\n        return board[cell] === self;\n      }).length;\n      const full = advantage + threat === 4;\n\n      if (!full) {\n        if (threat > advantage && threat > priority) {\n          streak.forEach(cell => {\n            if (!board[cell]) {\n              bestMove = cell;\n            }\n\n            priority = threat;\n          });\n        } else if (advantage > threat && advantage > priority) {\n          streak.forEach(cell => {\n            if (!board[cell]) {\n              bestMove = cell;\n            }\n\n            priority = advantage;\n          });\n        }\n      }\n\n      console.log(\"\".concat(streak, \": threat: \").concat(threat, \" advantage: \").concat(advantage, \" full: \").concat(full));\n    });\n    console.log(\"priority: \".concat(priority));\n  }\n\n  console.log(\"best move: \".concat(bestMove, \" score: \").concat(bestScore));\n  return bestMove;\n};\nexport const aiMove = (bestMove, board, difficulty) => {\n  // AI will make his move based on the difficulty level.\n  const moves = getAvailableMoves(board);\n  const randomChoice = moves[Math.floor(Math.random() * moves.length)];\n  let choice;\n\n  if (difficulty === 'novice') {\n    if (Math.random() * 100 <= 60) {\n      choice = bestMove;\n    } else {\n      choice = randomChoice;\n    }\n\n    console.log(\"Novice Move: \".concat(choice));\n  } else if (difficulty === 'easy') {\n    if (Math.random() * 100 <= 20) {\n      choice = bestMove;\n    } else {\n      choice = randomChoice;\n    }\n\n    console.log(\"Easy Move: \".concat(choice));\n  } else if (difficulty === 'expert') {\n    choice = bestMove;\n    console.log(\"expert Move: \".concat(choice));\n  }\n\n  return choice;\n};","map":{"version":3,"sources":["/Users/lttttoai/Documents/GitHub/carovn/src/acctions/aiAction.js"],"names":["streaks","nine","sixteen","indicateVictory","cells","grid","possibleStreaks","i","length","a","b","c","winner","winningRow","d","getGameScore","movesCount","score","urgency","getAvailableMoves","board","available","forEach","cell","cellIndex","push","minMax","xTurn","depth","moves","move","newBoard","slice","moveScore","getBestMove","bestScore","bestMove","console","log","newScore","enemy","self","threat","advantage","priority","openers","opener","streak","filter","full","aiMove","difficulty","randomChoice","Math","floor","random","choice"],"mappings":"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","sourcesContent":["/* eslint-disable no-return-assign */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-console */\nconst streaks = {\n  nine: [\n    // all the possible line streaks that could make a winner.\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6]\n  ],\n  sixteen: [\n    [0, 1, 2, 3, 4],\n    [2, 3, 4, 5, 6],\n    [3, 4, 5, 6, 7],\n    [4, 5, 6, 7, 8],\n    [5, 6, 7, 8, 9],\n    [6, 7, 8, 9, 10],\n    [7, 8, 9, 10, 11],\n    [8, 9, 10, 11, 12],\n    [9, 10, 11, 12, 13],\n    [10, 11, 12, 13, 14],\n    [11, 12, 13, 14, 15],\n    [12, 13, 14, 15, 16],\n    [13, 14, 15, 16, 17],\n    [14, 15, 16, 17, 18],\n    [15, 16, 17, 18, 19],\n    [16, 17, 18, 19, 20],\n    [17, 18, 19, 20, 21],\n    [18, 19, 20, 21, 22],\n    [19, 20, 21, 22, 23],\n    [20, 21, 22, 23, 24],\n    [21, 22, 23, 24, 25],\n    [22, 23, 24, 25, 26],\n    [23, 24, 25, 26, 27],\n    [24, 25, 26, 27, 28],\n    [25, 26, 27, 28, 29],\n    [26, 27, 28, 29, 30],\n    [0, 4, 8, 12, 14],\n    [1, 5, 9, 13, 17],\n    [2, 6, 10, 14, 18],\n    [3, 7, 11, 15, 19],\n    [0, 5, 10, 15, 20],\n    [3, 6, 9, 12, 15]\n  ]\n};\n\nconst indicateVictory = (cells, grid) => {\n  if (grid === 9) {\n    const possibleStreaks = streaks.nine;\n    for (let i = 0; i < possibleStreaks.length; i += 1) {\n      const [a, b, c] = possibleStreaks[i];\n      if (cells[a] && cells[a] === cells[b] && cells[a] === cells[c]) {\n        return {\n          winner: cells[a],\n          winningRow: [a, b, c]\n        };\n      }\n    }\n  } else if (grid === 16) {\n    const possibleStreaks = streaks.sixteen;\n    for (let i = 0; i < possibleStreaks.length; i += 1) {\n      const [a, b, c, d] = possibleStreaks[i];\n      if (\n        cells[a] &&\n        cells[a] === cells[b] &&\n        cells[a] === cells[c] &&\n        cells[a] === cells[d]\n      ) {\n        return {\n          winner: cells[a],\n          winningRow: [a, b, c, d]\n        };\n      }\n    }\n  }\n  return {\n    winner: null,\n    winningRow: [null, null, null]\n  };\n};\nconst getGameScore = (winner, movesCount) => {\n  let score;\n  const urgency = movesCount === 0 ? -80 : movesCount;\n  // if its an immediate win return highest score always.\n  if (winner === 'X') {\n    score = -20 + urgency;\n  } else if (winner === 'O') {\n    score = 20 - urgency;\n  } else {\n    score = 0;\n  }\n  return score;\n};\nconst getAvailableMoves = board => {\n  // returns an array of available cells\n  const available = [];\n  board.forEach((cell, cellIndex) => {\n    if (cell === null) {\n      available.push(cellIndex);\n    }\n  });\n  return available;\n};\nconst minMax = (board, xTurn, grid, depth = 0) => {\n  const { winner } = indicateVictory(board, grid);\n  let score = null;\n  const moves = getAvailableMoves(board);\n  if (winner || moves.length === 0) {\n    return getGameScore(winner, depth);\n  }\n  moves.forEach(move => {\n    const newBoard = board.slice();\n    newBoard[move] = xTurn ? 'X' : 'O';\n    const moveScore = minMax(\n      newBoard,\n      !xTurn,\n      grid,\n      // eslint-disable-next-line no-param-reassign\n      ++depth\n    );\n    if (xTurn) {\n      if (moveScore < score || score === null) {\n        score = moveScore;\n      }\n    } else if (moveScore > score || score === null) {\n      score = moveScore;\n    }\n  });\n  return score;\n};\n\nexport const getBestMove = (board, grid, xTurn) => {\n  let bestScore = null;\n  let bestMove = null;\n  const moves = getAvailableMoves(board);\n  console.log(`available moves: ${moves.length}`);\n  console.log(moves);\n  // on 4x4 grid recursive analysis is applied for 8 or less options.\n  if (grid === 9 || moves.length <= 8) {\n    if (grid === 9 && moves.length === 8 && !board[4]) {\n      return (bestMove = 4);\n    }\n    moves.forEach(move => {\n      const newBoard = board.slice();\n      newBoard[move] = xTurn ? 'X' : 'O';\n      const newScore = minMax(newBoard, !xTurn, grid);\n      console.log(`${move}'s score: ${newScore}`);\n      if (xTurn) {\n        if (newScore < bestScore || bestScore === null) {\n          bestScore = newScore;\n          bestMove = move;\n        }\n      } else if (newScore > bestScore || bestScore === null) {\n        bestScore = newScore;\n        bestMove = move;\n      }\n    });\n  } else {\n    /* for 4x4 grids I implemented simple logic for the first few moves to reduce system overload.\n      Recursive analysis of 9 or more available moves will decrease performance and might even cause the game to crash.\n\n      This logic calculates threat and advantage of current board's state, compares the two and prioritises the highest.\n      Then the AI makes his move based on his current priority, if it is to block a threat or build up an advantage. */\n    const enemy = xTurn ? 'O' : 'X';\n    const self = xTurn ? 'X' : 'O';\n    let threat;\n    let advantage;\n    let priority = -1;\n    if (moves.length === 16) {\n      const openers = [0, 3, 12, 15];\n      openers.forEach(opener => {\n        if (!board[opener]) {\n          bestMove = opener;\n        }\n      });\n    }\n    streaks.sixteen.forEach(streak => {\n      threat = streak.filter(cell => {\n        return board[cell] === enemy;\n      }).length;\n      advantage = streak.filter(cell => {\n        return board[cell] === self;\n      }).length;\n      const full = advantage + threat === 4;\n      if (!full) {\n        if (threat > advantage && threat > priority) {\n          streak.forEach(cell => {\n            if (!board[cell]) {\n              bestMove = cell;\n            }\n            priority = threat;\n          });\n        } else if (advantage > threat && advantage > priority) {\n          streak.forEach(cell => {\n            if (!board[cell]) {\n              bestMove = cell;\n            }\n            priority = advantage;\n          });\n        }\n      }\n      console.log(\n        `${streak}: threat: ${threat} advantage: ${advantage} full: ${full}`\n      );\n    });\n    console.log(`priority: ${priority}`);\n  }\n  console.log(`best move: ${bestMove} score: ${bestScore}`);\n  return bestMove;\n};\n\nexport const aiMove = (bestMove, board, difficulty) => {\n  // AI will make his move based on the difficulty level.\n  const moves = getAvailableMoves(board);\n  const randomChoice = moves[Math.floor(Math.random() * moves.length)];\n  let choice;\n  if (difficulty === 'novice') {\n    if (Math.random() * 100 <= 60) {\n      choice = bestMove;\n    } else {\n      choice = randomChoice;\n    }\n    console.log(`Novice Move: ${choice}`);\n  } else if (difficulty === 'easy') {\n    if (Math.random() * 100 <= 20) {\n      choice = bestMove;\n    } else {\n      choice = randomChoice;\n    }\n    console.log(`Easy Move: ${choice}`);\n  } else if (difficulty === 'expert') {\n    choice = bestMove;\n    console.log(`expert Move: ${choice}`);\n  }\n  return choice;\n};\n"]},"metadata":{},"sourceType":"module"}